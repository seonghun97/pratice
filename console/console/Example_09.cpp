#include<iostream>

#pragma region 포인터
/*
▶ 포인터 (Pointer)
- 포인터는 주소를 저장한다
- 모든 데이터는 메모리상에 특정한 공간에 저장되어 있음
- 기존의 우리가 알고있는 변수는 데이터를 저장하지만 포인터는 메모리 공간의 주소를 저장한다.
- 포인터 변수가 주소를 저장하려면 변수의 주소를 알아야함.
ㄴ 변수이름앞에 &연산자를 붙히면 해당 변수의 시작주소를 반환한다.
- 또한 포인터 변수가 저장하는 변수의 주소에 저장된 값을 참조하려면 
		*연산자를 사용한다.
& : 특정한데이터의 메모리 상의 주소값을 알수있다.
* : &연산자가 어떤 데이터의 주소값을 얻어내는 연산자라면 
주소값에서 해당 주소값에 대응되는 데이터를 가져온다.

int* p;  포인터 변수(주소값만 저장할수있음)

포인터변수는 주소만 저장하는녀석인대 타입이있는이유는
타입이없으면 얼마만큼의 메모리를 읽어야 하는지 방법이 없기때문에


*/
#pragma endregion


int main()
{
	int* p; //포인터 변수p선언

	int a = 2;
	p = &a; // 변수 a의 주소를 저장
	std::cout <<"p의 값(변수 a의 주소값) : " << p << std::endl;
	std::cout << a << std::endl;
	std::cout << "*p의 값(a의 값) :" << *p << std::endl;
	*p = 100;
	std::cout << "변경후 : *p의 값(a의 값) :" << *p << std::endl;



	//int num;
	//const int* pa = &num;
	//int b;
	//const int*
	/*
		const int형 변수를 가르킨다는 것이 아니라
		int형 변수를 가리키는대 그 값을 절대로 바꾸지 말라는 뜻
		즉, pa는 어떤 int형 변수를 가리키고 있고 const가 붙어있기때문에
		pa가 가르키는 변수의 값은 절대로 바뀌면 안된다.
	*/
	//*pa = 3; //error
	//pa = &b; //ok
	
	int a, b;
	//const int*
	//int* const 
	int* const pa = &a;

	//*pa = 3;//ok
	//pa = &b; -> error
	//ㄴpa의 값이 바뀌면 안된다는것.
	//위에서는 a의 주소를 저장
	//pa는 절대적으로 바뀌면안되지만 b의 주소를 담으려고 했기때문에 에러

	//const int*의 경우 변수가 가리키는대상의 주소값은 수정가능 하지만 실제값을 수정할수는없음
	//int* const의 경우 const가 변수이고 실제값을 수정할수는 있지만 변수가 가리키는 대상의 주소는 수정할수없음


}